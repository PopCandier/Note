#### 认识Volatile

首先，java中地Volatile可以实现可见性。

例如，以下代码，

```java
package pop.thread.demo3;

/**
 * @author Pop
 * @date 2019/6/18 22:48
 */
public class VolatileDemo {

    public volatile  static boolean volatile_stop = false;
    public static boolean unvolatile_stop;false;
    public static void main(String[] args) throws InterruptedException {

        Thread thread = new Thread(()->{
            int i =0;
            while(!volatile_stop){
                i++;
            }
        });
        thread.start();
        Thread.sleep(1000);
        stop=true;
    }

}

```

如果我们使用`volatile_stop`来作为停止线程工作地标签，在一秒后，线程将会完成他地任务，并且退出线程，而`unvolatile_stop`的改变将不会被让程序停止下来，他将一直运行下去，这里我们可以得到初步地结论。

加了`volatile`得变量，他们改变对于其他线程是`可感知`地，也就是说被修饰地变量对于其他线程而言是具有`可见的性`，而未加地变量如果发生改变，其他线程是感觉不到地，也就是`不可见`的。

#### Volatile的意义

如果你cpu核心只有一颗，无论读操作还是写操作都是它去操作，所以它自己是知道此刻这个变量地状态是什么，所以不存在可见性地问题。

当cpu核心数多了后，硬件层面可以支持地线程多起来后，能操作这个变量的人也多了起来，那么当线程A去改变变量地值地时候，线程B又怎么知道此时这个变量是否是最新的值，又或者这个变量会不会发生了变化。

变量明明已经发生了变化，线程B还拿着还未更新的以前地变量去操作，势必会得到错误地预期结果。

#### 从硬件层面谈起

总的来说，能够较大影响一台计算机性能的组件

* CPU
* 内存
* IO设备

当然，我们知道一台计算机性能地高低，取决于三者地共同表现，例如电脑地磁盘的IO操作慢，那么你地内存再大，CPU能够支撑的线程数再多也没有意义。

这三者的处理速度越靠近CPU越快。CPU>内存>IO设备。

同时，为了提高他们各自的性能，也提出了许多地概念并给予了实现。

##### CPU高速缓存

我一直将CPU使用数据进行计算看做是一个人在吃饭。数据就是面包。

IO设备相当于用来放面包的盘子，内存是我们的手，已经有一部分面包被我们从盘子中拿起，而高速缓存则是我们的嘴巴，它已经在咀嚼送入嘴里地面包了。

我们地最终目的是为了吃面包，而要送入嘴巴过程需要经过盘子(IO设备)、手(内存)、嘴(高速缓存)

。同样我们也很明了，嘴是最容易处理面包步骤，因为我们只需要咀嚼就可以吃饱，而前两者则需要，`拿起来`，`送进嘴里去`，这样的步骤。

回到硬件层面，高速缓存的引入也是为了这样的情况，cpu处理速度其实是很快的，但为他加载需要得数据确是漫长得过程，从磁盘到内存，然后在拿内存中的数据进行计算，这过程中发生了阻塞都会影响CPU的计算性能。

为了更好解决这个问题，高速缓存被提了出来，高速缓存可以理解成是存在CPU的一块内存，之前我们说过越靠近CPU，交互的速度也就越快，而高速缓存对于CPU来说就是`触手可及`的距离。

![1560871864373](C:\Users\99405\AppData\Roaming\Typora\typora-user-images\1560871864373.png)

当然，我们从`任务管理器`也可以看到这些缓存的实际大小

![1560871930215](C:\Users\99405\AppData\Roaming\Typora\typora-user-images\1560871930215.png)

高速缓存中也分了级别，所有线程公用的L3级别缓存，和每个核心都自己独有地L2和L1缓存。

这里，其实我们地CPU性能已经得到一定程度的提升，因为我们每次都会从主内存中将一些数据复制到我们的高速缓存中，这样就可以提高的处理地速度，可是这就存在一个问题，那就是`缓存一致性`。



